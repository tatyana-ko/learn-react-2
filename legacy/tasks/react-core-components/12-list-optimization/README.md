# Оптимизация списков в React

## Теория

При работе с большими списками в React часто возникают проблемы с производительностью:
1. Рендеринг всех элементов сразу приводит к медленной начальной загрузке
2. Тяжелая фильтрация и сортировка блокируют UI
3. Частые ререндеры при обновлении состояния
4. Плохой UX при прокрутке большого списка

Для решения этих проблем используются следующие техники:
- Виртуализация списка (react-window, react-virtualized)
- Оптимизация фильтрации и сортировки
- Мемоизация компонентов и вычислений
- Бесконечная прокрутка или пагинация

## Задача

В этом проекте реализован список пользователей с фильтрацией, сортировкой и поиском. Однако есть несколько проблем с производительностью:

1. Все 10,000 пользователей рендерятся сразу
2. Фильтрация и сортировка выполняются при каждом изменении
3. Отсутствует виртуализация списка
4. UI блокируется при тяжелых операциях

### Требования

1. Внедрите react-window для виртуализации списка
2. Оптимизируйте фильтрацию и сортировку с помощью useMemo
3. Добавьте мемоизацию для компонентов списка
4. Улучшите UX при загрузке и скролле:
   - Добавьте плейсхолдеры
   - Реализуйте плавную прокрутку
   - Добавьте индикаторы загрузки

### Подсказки

1. Изучите документацию react-window:
   ```typescript
   import { FixedSizeList } from 'react-window';
   
   const Row = ({ index, style }) => (
     <div style={style}>Row {index}</div>
   );
   
   const List = () => (
     <FixedSizeList
       height={400}
       width={300}
       itemCount={1000}
       itemSize={35}
     >
       {Row}
     </FixedSizeList>
   );
   ```

2. Используйте useMemo для тяжелых вычислений:
   ```typescript
   const filteredUsers = useMemo(() => {
     return users.filter(user => 
       user.name.toLowerCase().includes(searchTerm)
     );
   }, [users, searchTerm]);
   ```

3. Оптимизируйте компоненты с помощью React.memo:
   ```typescript
   const UserRow = React.memo(({ user }) => (
     <div className="user-row">{user.name}</div>
   ));
   ```

## Критерии приемки

1. Список должен плавно прокручиваться даже с 10,000 элементов
2. Поиск и фильтрация не должны блокировать UI
3. Должны быть реализованы все требования по UX
4. Код должен быть чистым и хорошо организованным
